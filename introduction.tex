The algorithmic study of cuts and flows is one of the pillars of combinatorial optimization. The foundations of this field were laid 
in the celebrated work of Ford and Fulkerson in the mid-50s~\cite{FordF56}. They studied the $s-t$ edge connectivity problem, namely finding a set of edges of minimum weight whose removal disconnects two vertices $s$ from $t$ in a graph (such a set of edges is called an $s-t$ mincut). They showed that the weight of an $s-t$ mincut equals the maximum flow between $s$ and $t$ in the graph, a duality that has underpinned much of the success in this field. Soon after their work, in a remarkable result, Gomory and Hu~\cite{GomoryH61} showed that by using just $n-1$ maxflows, they could construct a tree $T$ on the vertices of an undirected graph $G$ such that for every pair of vertices $s$ and $t$, the $s-t$ edge connectivity in $T$ was equal to that in $G$. In other words, the $n\choose 2$ pairs of vertices had at most $n-1$ different edge connectivities and they could be obtained using just $n-1$ maxflow calls. Moreover, for all vertex pairs $s$ and $t$, the bipartition of vertices in the $s-t$ mincut in tree $T$ (note that this is just the bipartition created by removing the minimum weight edge on the unique $s-t$ path in $T$) was also an $s-t$ mincut in graph $G$. This data structure, called a {\em cut tree} or more appropriately a {\em Gomory-Hu tree} (abbreviated GH-tree) after its creators, has become a standard feature in algorithms textbooks, courses, and research since their work.

But, rather surprisingly, in spite of the remarkable successes in this field as a whole, the best algorithm for constructing a GH-tree remains the one given by Gomory and Hu almost six decades after their work. There have been alternatives suggested along the way, although none of them unconditionally improves on the original construction. Gusfield~\cite{Gusfield} gave an algorithm that also uses $n-1$ maxflows, but on the original graph itself (the GH algorithm runs maxflows on contracted graphs as we will see later) to improve the performance of the algorithm in practice. Bhalgat~{\em et al.}~\cite{BhalgatHKP08} (see also \cite{HariharanKP07}) obtained an $\tO(mn)$ algorithm for this problem, but only for unweighted graphs. (Note that using the state of the art maxflow algorithms~\cite{liu2020faster}, the GH algorithm has a running time of $m^{4/3+o(1)}n$ for unweighted graphs, which is slower.) Karger and Levine~\cite{KargerL} matched this running time using a randomized maxflow subroutine, also for unweighted graphs. Recently, Abboud~{\em et al.}~\cite{AbboudKT20a} improved this bound for {\em sparse} unweighted graphs to $\tO(m^{3/2}n^{1/6})$, thereby demonstrating that the $\tO(mn)$ is not tight, at least in certain edge density regimes. Further improvements have been obtained in special cases: in particular, near-linear time algorithms are known for planar graphs~\cite{BorradaileSW15} and surface-embedded graphs~\cite{BorradaileENW16}. Experimental studies of GH tree algorithms have also been performed~\cite{GoldbergT01}. The reader is referred to a survey article on this topic for more background~\cite{P16}.

In spite of all the works described above, the status of the GH tree problem for general weighted graphs has remained unchanged for the last six decades. Namely, we know that a GH tree can be constructed using $n-1$ maxflows, but no better. In fact, surprisingly, a faster GH tree algorithm is not known {\em even if one allowed approximations}, i.e., if the $s-t$ mincuts in the GH tree and those in the original graph could differ by a multiplicative factor. At first glance, this would appear surprising, since $\tO(m)$-time algorithms for  $(1+\e)$-approximation of maxflows are known. (In contrast, obtaining an exact maxflow algorithm that runs in near-linear time remains one of the major open challenges in graph algorithms.) But, the difficulty in using these faster approximate maxflow algorithms in the GH tree problem is that the GH algorithm (and also Gusfield's algorithm) use recursive calls in a manner that approximation errors can build up across the different recursive layers of the algorithm. Approximation, however, does present some advantage, in that one can use standard graph sparsification techniques to reduce the number of edges to $\tO(n)$ (see, e.g., \cite{BenczurK00,FungHKP11}) and then apply the GH algorithm (with exact maxflow) on this sparse graph. This reduces the running time to $n-1$ invocations of maxflow on $\tO(n)$-edge graphs, which has a total running time of $\tO(n^{5/2})$ using the current state of the art maxflow algorithm of Lee and Sidford~\cite{Lees14}. But, fundamentally, even allowing approximations, we do not have a GH tree algorithm that beats the $O(n)$ maxflows benchmark set by the original GH algorithm.

But, there has been some exciting progress of late in this line of research. Very recently, in a beautiful paper, Abboud~{\em et al.}~\cite{AbboudKT20b} showed that the problem of finding all pairs edge connectivities (that a GH tree obtains) can be reduced to $\polylog(n)$ instances of the single source mincut problem (we call this is \ssc problem). Given a fixed source vertex $s$, the latter problem asks for the $s-t$ edge connectivity of $s$ with every other vertex $t$. This reduction is also robust to approximations because, crucially, the recursive depth of the reduction is only $\polylog(n)$ (as against the recursive depth of GH and Gusfield's algorithms, which can be $\Omega(n)$). So, in essence, they reduced the recursive depth of the algorithm in exchange for using a more powerful primitive, namely edge connectivity for $n-1$ pairs of vertices (one of the pair is common) rather than for just a single pair. The algorithm that they used to solve the single source edge connectivity problem is the obvious one: run $s-t$ maxflow for every vertex $t$. Naturally, this does not improve the running time for exact all pairs edge connectivity, since we are still running $n-1$ maxflows. But, importantly, if approximations are allowed, we can now use the $\tO(m)$-time approximate maxflow algorithm rather than the exact one. Coupled with sparsification, this yields a running time bound of $\tO(n^2)$ improving on the previous bound of $\tO(n^{5/2})$. 

However, while this improves the time complexity of approximate all pairs edge connectivity, the reduction framework of \cite{AbboudKT20b} does not support the construction of an approximate GH tree. Namely, they give a data structure (called a {\em flow tree}) that returns the (approximate) edge connectivity of a vertex pair when queried, but does not return a mincut for that pair. Nevertheless, this result creates a range of possibilities, now that we have a technique for designing computation trees for all pairs edge connectivity that have small recursive depth. In this paper, we give the first approximation algorithm (our approximation factor is $1+\e$ for any $\e>0$) for GH tree that beats the running time of $n-1$ maxflow calls. Namely, we show that a $(1+\e)$-approximate GH-tree can be constructed using polylog number of calls to an exact maxflow subroutine, plus $\tO(m)$ time outside these maxflow calls.

\subsection{Our Results}

\alert{DP: Should we formally define the problem statements here?}

We now state our main theorem that obtains a $(1+\e)$-approximate GH tree for weighted graphs:
\begin{restatable}{theorem}{ApproxW}\thml{approx-w}
    Let $G$ be an undirected graph with non-negative edge weights. There is a randomized algorithm that w.h.p., outputs a $(1+\e)$-approximate Gomory-Hu tree and runs in $\tO(m)$ time plus calls to max-flow on instances with a total of $\tO(n\e\inv\log^2\De)$ vertices and $\tO(n\e\inv\log^2\De)$ edges, where $\De$ is the ratio of maximum to minimum edge weights. Assuming polynomially bounded edge weights and using the $\tO(m+n^{3/2})$ time max-flow algorithm of \alert{???}, the algorithm runs in $\tO(m+n^{3/2})$ time.
\end{restatable}
For unweighted graphs, we obtain the following result, which gives a better running time for sparse graphs (if $m = o(n^{9/8})$):
\begin{restatable}{theorem}{ApproxU}\thml{approx-u}
Let $G$ be an unweighted, undirected graph. There is a randomized algorithm that w.h.p., outputs a $(1+\e)$-approximate Gomory-Hu Steiner tree and runs in $\tO(m)$ time plus calls to max-flow on unweighted instances with a total of $\tO(n\e\inv)$ vertices and $\tO(m\e\inv)$ edges. Using the $m^{4/3+o(1)}$-time max-flow algorithm for unweighted graphs of Liu and Sidford~\cite{liu2020faster}, the algorithm runs in $m^{4/3+o(1)}\e\inv$ time.
\end{restatable}

Note that our algorithm improves on the previous best $(1+\e)$-approximate GH tree algorithm by a factor of $n$ and that for the fastest all pairs $(1+\e)$-approximate edge connectivity algorithm~\cite{AbboudKT20} by a factor of $\sqrt{n}$, assuming polynomial edge weights. (The improvements are slightly better for unweighted graphs with $m=o(n^{9/8})$ where the second theorem yields better bounds.) More importantly, this is the first algorithm for (approximate) GH tree that goes beyond $n-1$ maxflow calls in general weighted graphs. Uur reduction to maxflow instances is ``black box'', i.e., any maxflow algorithm can be used; as a consequence, if one were to assume that eventually maxflow would be solved in $\tO(m)$-time, as is often conjectured, then these theorems would automatically yield an $\tO(m)$-time algorithm for a $(1+\e)$-approximate GH tree.

Given these results, one might be tempted to replace the exact maxflow calls in our algorithm by approximate maxflow subroutines. Indeed, if this were possible, the running time of the overall algorithm would be $\tO(m)$ without additional assumptions (i.e., without assuming a $\tO(m)$-time exact maxflow algorithm). Unfortunately, a key tool that we employ called the {\em isolating cuts lemma}, which was recently introduced by the authors for the deterministic mincut problem~\cite{LiP20}, requires the computation of exact maxflows; we are not aware of any approximation versions of this lemma. We leave the problem of obtaining a near-linear time approximate GH tree algorithm as an interesting open question (that is probably easier than an exact $\tO(m)$-time maxflow algorithm).


Recall that Abboud~{\em et al.}~\cite{AbboudKT20b} recently reduced the all pairs mincuts problem to $\polylog(n)$ calls to single source mincuts (\ssc). They then used $n-1$ maxflows to solve the latter problem. In this context, our work can be viewed as combining two goals: (a) showing that the \ssc problem can be approximately solved using $\polylog(n)$ maxflows calls, and (b) obtaining an approximate GH tree by carefully structuring the \ssc instances in the reduction. For (a), our main tool is the following subroutine that we call the {\em Cut Threshold} (\ct) problem \alert{better name?}, which may have further applications on its own:

\begin{restatable}{theorem}{Thr}\thml{thr}
Let $G=(V,E)$ be a weighted, undirected graph, and let $s\in V$, and let $\la\ge0$ be a parameter. There is an algorithm that outputs all vertices $v\in V$ with $\mincut(s,v)\le\la$, and runs in $\tO(m)$ time plus $\pl(n)$ calls to max-flow instances on $O(n)$-vertex, $O(m)$-edge graphs.
\end{restatable}

In particular, this theorem implies an algorithm for approximately solving the \ssc problem that is faster than running approximate maxflows for all the $n-1$ vertices separately:

\begin{restatable}{theorem}{SSMC}\thml{ssmc}
Let $G$ be a weighted, undirected graph, and let $s\in V$. There is an algorithm that outputs, for each vertex $v\in V\sm\{s\}$, a $(1+\e)$-approximation of $\mincut(s,v)$, and runs in $\tO(m\log\De)$ time plus $\pl(n)\cdot \log\De$ calls to max-flow on $O(n)$-vertex, $O(m)$-edge graphs, where $\De$ is the ratio of maximum to minimum edge weights.
\end{restatable}

Using the framework of Abboud {\em et al.}~\cite{AbboudKT20b} for a $(1+\e)$-approximate \apc using $\polylog(n)$ \ssc calls, this theorem improves the running time of the $(1+\e)$-approximate flow tree problem from $n-1$ approximate maxflows in \cite{AbboudKT20b} to $\polylog(n)\cdot \log \De$ exact maxflows. Using current best maxflow algorithms, the runtime improves from $\tO(mn)$ to $\tO(m\sqrt{n})$.

\subsection{Our Techniques}

To sketch our main ideas, let us first think of the \ct problem (\thm{thr}). Note that this theorem is already sufficient to obtain the improved the running times for the \ssc and \apc problems, although obtaining a $(1+\e)$-approximate GH tree needs additional ideas. To solve the \ct problem, our main tool is the {\em isolating cuts lemma}, introduced by the authors recently for solving the deterministic mincut problem~\cite{LiP20}. We first describe this tool.
%
\BD[Minimum isolating cuts]
Consider a weighted, undirected graph $G=(V,E)$ and a subset $R\s V$ ($|R|\ge2$). The \emph{minimum isolating cuts} for $R$ is a collection of sets $\{S_v:v\in R\}$ such that for each vertex $v\in R$, the set $S_v$ satisfies $S_v\cap R=\{v\}$ and has the minimum value of $w(\pt S'_v)$ over all sets $S'_v$ satisfying $S'_v\cap R=\{v\}$.
\ED
%
%\alert{DP: In the above definition, should we also mention that sets $S_v$ must be disjoint? At the moment, this is in the next lemma. Would putting it in the definition might make life a bit easier in terms of just having to refer to the definition when invoking this property?}
%
\BL [Isolating Cuts Lemma~\cite{LiP20})]
Fix a subset $R\s V$ ($|R|\ge2$). There is an algorithm that computes the minimum isolating cuts $\{S_v:v\in R\}$ for $R$ using $O(\log|R|)$ calls to $s$--$t$ max-flow on weighted graphs of $O(n)$ vertices and $O(m)$ edges, and takes $\tO(m)$ deterministic time outside of the max-flow calls. If the original graph $G$ is unweighted, then the inputs to the max-flow calls are also unweighted. Moreover, the sets $\{S_v:v\in R\}$ are disjoint.
\EL
%
The crucial aspect of the isolating cuts lemma is that the number of maxflow calls is $O(\log n)$ {\em irrespective of the size of $R$}. For the \ct problem, define $T= V\setminus \{s\}$; our goal is to invoke the above lemma $\polylog(n)$ times and identify all the vertices $v\in T$ such that the $\mincut(s, v)\le \lambda$. In fact, we will only describe an algorithm that identifies each vertex in $T$ satisfying this condition with probability $\Omega(1/\polylog(n))$; removing these vertices from $T$ and repeating $O(\log n)$ times identifies all such vertices in $T$ whp. Fix a GH tree $T$ of the graph rooted at $s$, and let $(u, v)$ be an edge of weight $\le \lambda$ in $T$ where $u$ is closer to $s$. Let $n_v$ be the number of vertices in the subtree under $v$ in $T$; for any vertex $z$ in this subtree, we have $\mincut(s, z) \le \lambda$.